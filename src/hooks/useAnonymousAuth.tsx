/**
 * React Hook for Anonymous Authentication
 * Provides easy integration with the anonymous auth system
 */

import React, { useState, useEffect, useCallback, createContext, useContext } from 'react';
import AnonymousAuthenticationSystem, { 
  AnonymousUser, 
  Session, 
  DeviceInfo, 
  UserPreferences 
} from '../lib/anonymous-auth-system';

interface AuthContextType {
  user: AnonymousUser | null;
  session: Session | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: () => Promise<boolean>;
  logout: () => Promise<void>;
  updatePreferences: (preferences: Partial<UserPreferences>) => Promise<boolean>;
  generateRecoveryTokens: () => Promise<string[]>;
  recoverAccount: (token: string) => Promise<boolean>;
  exportData: () => Promise<any>;
  deleteAccount: () => Promise<boolean>;
  trustScore: number;
  deviceFingerprint: string;
}

const AuthContext = createContext<AuthContextType | null>(null);

// Singleton auth system instance
let authSystem: AnonymousAuthenticationSystem | null = null;

const getAuthSystem = (): AnonymousAuthenticationSystem => {
  if (!authSystem) {
    authSystem = new AnonymousAuthenticationSystem({
      sessionDuration: 24 * 60 * 60 * 1000, // 24 hours
      maxSessionsPerDevice: 3,
      recoveryTokenValidityPeriod: 7 * 24 * 60 * 60 * 1000, // 7 days
      maxRecoveryTokens: 5,
      auditRetentionPeriod: 365 * 24 * 60 * 60 * 1000, // 1 year
      trustScoreThreshold: 0.3
    });
  }
  return authSystem;
};

/**
 * Generate device fingerprint from browser information
 */
const generateDeviceInfo = (): DeviceInfo => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const canvasFingerprint = ctx ? ctx.getImageData(0, 0, 1, 1).data.toString() : '';

  return {
    userAgent: navigator.userAgent,
    language: navigator.language,
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    screenResolution: `${screen.width}x${screen.height}`,
    platform: navigator.platform,
    hashedFingerprint: '' // Will be generated by auth system
  };
};

/**
 * Get client IP address (anonymized)
 */
const getClientIP = async (): Promise<string | undefined> => {
  try {
    // In production, this would come from your API
    // For demo purposes, we'll use a placeholder
    return '127.0.0.1';
  } catch {
    return undefined;
  }
};

export const useAnonymousAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAnonymousAuth must be used within an AuthProvider');
  }
  return context;
};

interface AuthProviderProps {
  children: React.ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<AnonymousUser | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [deviceFingerprint, setDeviceFingerprint] = useState('');

  const authSystem = getAuthSystem();

  // Initialize authentication on mount
  useEffect(() => {
    initializeAuth();
  }, []);

  const initializeAuth = async () => {
    setIsLoading(true);
    
    try {
      // Generate device fingerprint
      const deviceInfo = generateDeviceInfo();
      const fingerprint = authSystem.generateDeviceFingerprint(deviceInfo);
      setDeviceFingerprint(fingerprint);

      // Check for existing session in localStorage
      const storedSessionToken = localStorage.getItem('sata_session_token');
      
      if (storedSessionToken) {
        // Validate existing session
        const authResult = await authSystem.validateSession(storedSessionToken);
        
        if (authResult) {
          setUser(authResult.user);
          setSession(authResult.session);
        } else {
          // Invalid session, clean up
          localStorage.removeItem('sata_session_token');
          
          // Try device-based authentication
          const deviceAuthResult = await authSystem.authenticateWithDevice(
            fingerprint,
            await getClientIP()
          );
          
          if (deviceAuthResult) {
            setUser(deviceAuthResult.user);
            setSession(deviceAuthResult.session);
            localStorage.setItem('sata_session_token', deviceAuthResult.session.token);
          }
        }
      } else {
        // Try device-based authentication
        const deviceAuthResult = await authSystem.authenticateWithDevice(
          fingerprint,
          await getClientIP()
        );
        
        if (deviceAuthResult) {
          setUser(deviceAuthResult.user);
          setSession(deviceAuthResult.session);
          localStorage.setItem('sata_session_token', deviceAuthResult.session.token);
        }
      }
    } catch (error) {
      console.error('Authentication initialization failed:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const login = useCallback(async (): Promise<boolean> => {
    try {
      const deviceInfo = generateDeviceInfo();
      const fingerprint = authSystem.generateDeviceFingerprint(deviceInfo);
      
      // Try device-based authentication first
      let authResult = await authSystem.authenticateWithDevice(
        fingerprint,
        await getClientIP()
      );

      // If no existing account, create new anonymous account
      if (!authResult) {
        authResult = await authSystem.createAnonymousAccount(
          deviceInfo,
          {
            language: navigator.language.split('-')[0],
            theme: 'auto',
            notificationsEnabled: true,
            dataRetentionPeriod: 365,
            anonymityLevel: 'enhanced'
          },
          await getClientIP()
        );
      }

      if (authResult) {
        setUser(authResult.user);
        setSession(authResult.session);
        localStorage.setItem('sata_session_token', authResult.session.token);
        return true;
      }

      return false;
    } catch (error) {
      console.error('Login failed:', error);
      return false;
    }
  }, [authSystem]);

  const logout = useCallback(async (): Promise<void> => {
    if (session) {
      await authSystem.logout(session.token);
    }
    
    setUser(null);
    setSession(null);
    localStorage.removeItem('sata_session_token');
  }, [authSystem, session]);

  const updatePreferences = useCallback(async (
    preferences: Partial<UserPreferences>
  ): Promise<boolean> => {
    if (!user) return false;

    const success = await authSystem.updatePreferences(user.id, preferences);
    
    if (success) {
      // Update local user state
      setUser((prev: AnonymousUser | null) => prev ? { ...prev, preferences: { ...prev.preferences, ...preferences } } : null);
    }
    
    return success;
  }, [authSystem, user]);

  const generateRecoveryTokens = useCallback(async (): Promise<string[]> => {
    if (!user) throw new Error('No authenticated user');
    
    return await authSystem.generateRecoveryTokens(user.id);
  }, [authSystem, user]);

  const recoverAccount = useCallback(async (token: string): Promise<boolean> => {
    try {
      const deviceInfo = generateDeviceInfo();
      const fingerprint = authSystem.generateDeviceFingerprint(deviceInfo);
      
      const authResult = await authSystem.recoverAccountWithToken(
        token,
        fingerprint,
        await getClientIP()
      );

      if (authResult) {
        setUser(authResult.user);
        setSession(authResult.session);
        localStorage.setItem('sata_session_token', authResult.session.token);
        return true;
      }

      return false;
    } catch (error) {
      console.error('Account recovery failed:', error);
      return false;
    }
  }, [authSystem]);

  const exportData = useCallback(async (): Promise<any> => {
    if (!user) throw new Error('No authenticated user');
    
    return await authSystem.exportUserData(user.id);
  }, [authSystem, user]);

  const deleteAccount = useCallback(async (): Promise<boolean> => {
    if (!user) return false;

    const success = await authSystem.deleteUserData(user.id);
    
    if (success) {
      setUser(null);
      setSession(null);
      localStorage.removeItem('sata_session_token');
    }
    
    return success;
  }, [authSystem, user]);

  const contextValue: AuthContextType = {
    user,
    session,
    isAuthenticated: !!user && !!session,
    isLoading,
    login,
    logout,
    updatePreferences,
    generateRecoveryTokens,
    recoverAccount,
    exportData,
    deleteAccount,
    trustScore: user?.trustScore || 0,
    deviceFingerprint
  };

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
};

/**
 * Hook for authentication actions without context
 */
export const useAuthActions = () => {
  const authSystem = getAuthSystem();

  return {
    getComplianceReport: () => authSystem.getComplianceReport(),
    getStats: () => authSystem.getStats(),
    authSystem
  };
};
